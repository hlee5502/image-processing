/*
Haejin Lee
Image Processing
*/

/* function removeBlueAndGreen takes an image as an argument and returns a copy of
the input image, where each pixel is a shade of red. If
the color of a pixel is (r, g, b) in the input image, its
color in the outputi is (r, 0, 0). */

function removeBlueAndGreen(img) {
  let red = img.copy(); // red is copy of im which will be returned
  for (let i = 0; i < red.width; ++i){ // iterating through red's pixels by row
    for (let j = 0; j < red.height; ++j){ // iterating through each pixel in row i
        red.setPixel(i, j, [red.getPixel(i,j)[0], 0, 0]); // only takes first (red) parameter of pixel
    }
  }
  return red; // returns the red image
}

/* function shiftRGB takes an image as an argument and returns a copy of the input
image, where all the channels are shifted. If the color of a pixel is (r, g, b) in the input image, its color
in the output is (g, b, r).*/

function shiftRGB(img) {
  let newIm = img.copy(); // newIm is the image that will be returned
  for (let i = 0; i < newIm.width; ++i){ // iterating through the image pixels by row
    for (let j = 0; j < newIm.height; ++j){ // iterating through each pixel in row i
        newIm.setPixel(i, j, [newIm.getPixel(i,j)[1], newIm.getPixel(i,j)[2], newIm.getPixel(i,j)[0]]); // changes (r,g,b) to (g,b,r)
    }
  }
  return newIm; // returns the new image with (g,b,r) settings
}

/* function imageMap has the following type:
imageMap(img: Image, func: (p: Pixel) => Pixel): Image
The result is a new image with the same dimensions as img. The value of each pixel in the new
image should be the result of applying func to the corresponding pixel of img. Uses image.copy to make a copy of the original.
*/

function imageMap(img, func) {
  let newIm = img.copy();
  for (let i = 0; i < newIm.width; ++i){ // iterating through the image pixels by row
    for (let j = 0; j < newIm.height; ++j){ // iterating through each pixel in row i
        newIm.setPixel(i,j,func(newIm.getPixel(i,j))); // set new pixel as result of applying func to the pixel at i, j
    }
  }
  return newIm; // returns the new image with new settings applied by func
}

/* functions mapToRed and mapToGBR behave exactly like removeBlueAndGreen and shiftRGB but use imageMap.*/

function mapToRed(img) {
  return imageMap(img, p => [p[0], 0, 0] ); // calls image map to change image pixels from (r,g,b) to (r, 0, 0)
}

function mapToGBR(img) {
  return imageMap(img, p => [p[1], p[2], p[0]] ); // calls image map to change image pixels from (r,g,b) to (g,b,r)
}

/* function increaseContrast returns a copy of the input image where each color
channel of a pixel is shifted towards the closest of the two limits 0 or 1. Specifically, the difference to
the closest of the two limits (0 or 1) is decreased by 10% of its value. For example, 0.6 becomes 0.64
and 0.3 becomes 0.27. A channel value of 0.5 is not changed (but, as you will see, images cannot have
channel values of precisely 0.5).
Uses imageMap and map - no loops. */

function increaseContrast(img) {
  return imageMap(img, img => img.map(contrast)); // function will apply to each pixel of image and change its contrast
}

function contrast(p){
  if (p > 0.5) { p += (0.1 * (1-p));} // if pixel value is closer to 1, add 10% difference
  if (p < 0.5) { p -= (0.1*p);} // if pixel value is closer to 0, subtract 10% difference
  if (p >= 1) { return 1;} // check upper bound
  if (p <= 0) { return 0;} // check lower bound
  return p;
}


// More Image Processing with Higher-Order Functions

/* function imageMapXY has the following type:
    imageMapXY(img: Image, func: (img: Image, x: number, y: number) => Pixel): Image
  The result is a new image with the same dimensions as img. 
  The value of each pixel in the new image is the result of
  applying func to the corresponding pixel of img. 
  This function is more general than imageMap: the new pixel value 
  may also depend on the coordinates of the original pixel.
*/
function imageMapXY(img, func) {
  let newIm = img.copy(); // copy the image
  for (let x = 0; x < newIm.width; ++x){ // iterating through the image pixels by rows x
    for (let y = 0; y < newIm.height; ++y){ // iterating through each column y in row x
        newIm.setPixel(x,y,func(img, x, y)); // set new pixel as result of applying func to the pixel at x,y coordinates
    }
  }
  return newIm; // returns the new image with new settings applied by func
}

/* function imageMask has the following type:
  imageMask(img: Image, cond: (img: Image, x: number, y: number) => boolean, maskValue: Pixel): Image
  The result is a new image, in which the value of pixel at
  (x, y) is either (a) identical to the value of the pixel at (x, y) in the
  original image when cond(img, x, y) returns false or
  (b) the value maskValue when cond(img, x, y) returns true. Uses imageMapXY defined above.
*/
function imageMask(img, cond, maskValue){
  return imageMapXY(img, function(img, x, y){ // calls imageMapXY
     return cond(img, x, y)? maskValue : (img.getPixel(x,y))}); // if condition is true, return the mask value, if not return original value
}

/* function imageMapCond has the following type:
  imageMapCond(img: Image, cond: (img: Image, x: number, y: number) => boolean, 
  func: (p: Pixel) => Pixel): Image
  The result is a new image, where the value of pixel at (x, y) is either (a) identical to the value of the
  pixel at (x, y) in the original image when cond(img, x, y) returns false or (b) the value func(p),
  where p is the original pixel, when cond(img, x, y) returns true. No loops in this function, only imageMapXY
*/
function imageMapCond(img, cond, func){
  return imageMapXY(img, function(img, x, y){ // calls imageMapXY
     return cond(img, x, y)? func(img.getPixel(x,y)) : (img.getPixel(x,y));
    }); // return image of if condition is true, return pixel with function, or return original image pixel
}

/*
  4. function isGrayish has the following type: isGrayish(p: Pixel): boolean
  The result is true if and only if the difference between the maximum and minimum color channel
  value is at most 1/3.
*/
function isGrayish(p){
  let min = p.reduce((x,y) => Math.min(x,y), p[0]);
  let max = p.reduce((x,y) => Math.max(x,y), p[0]);
  return ((max-min) <= (1/3))? true: false;
}

/*
  5. function makeGrayish has the following type: makeGrayish(img: Image): Image
  The result is a new image, where each grayish pixel, as determined by the isGrayish() function, is
  left unchanged. Any other pixel is replaced with a grayscale pixel computed by averaging the three color
  channels, and setting all three channels in the new pixel to this value.
*/
function makeGrayish(img){
  return imageMapCond(img, // calls imageMapCond
  (img, x, y) => (isGrayish(img.getPixel(x,y)) === false), // condition is pixels that AREN'T grayish
  function(p){
    let avg = (p[0] + p[1] + p[2]) / 3;
    return [avg, avg, avg];}
  ); 
} // average above lol couldn't comment for some reason

/*
  6. function grayHalfImage has the following type: grayHalfImage(img: Image): Image
  The result is a new image that is the half-grayed version of the argument, where the top part of the
  image is grayed out and the bottom part of the image is in color. If the y-position is less than half of the
  image height, then this part is transformed like the makeGrayish function above.
*/
function grayHalfImage(img){
  return imageMapCond(img, 
   (img, x, y) => ( y < (1/2*(img.height)) && isGrayish(img.getPixel(x,y)) === false ) ,
  function(p){
    let avg = (p[0] + p[1] + p[2]) / 3;
    return [avg, avg, avg];}
  );
}
/*
  7. function blackenLow has the following type: blackenLow(img: Image): Image
  The result is a new image where, for each pixel, any channel value lower than 1/3 is set to 0 for the
  corresponding pixel in the new image. Other channels for the pixel are not modified.
*/
function blackenLow(img){
  return imageMapXY(img, 
  (img, x, y) => img.getPixel(x,y).map(x => (x < 1/3)? 0: x));
}

/* function blurPixel has following type: blurPixel(img: Image, x: number, y: number): Pixel
The result is the blurred value of the pixel at coordinates (x, y). To do this, the red channel of the resulting pixel is
the mean of the red channels of the pixels neighboring (x, y) and the (x, y) pixel itself. The blue
and green channels are computed in the same way. Two distinct pixels are neighbors if both their
x-coordinates and y-coordinates differ by at most 1 in absolute value.*/

function blurPixel(img, x, y) {
  function blurChannel(c) { // c is the rgb channel specified by 0, 1, or 2
    let result = []; // initialize an array to store neighbors and compute mean of channel c
    for (let i = x-1; i <= x+1; ++i) { // iterate through a square space with pixel at (x,y) as center
      for(let j = y-1; j <= y+1; ++j) {
        if( i >= 0 && i < img.width && j >= 0 && j < img.height) { // check bounds
          result.push(img.getPixel(i,j)[c]); // add the c'th channel of pixel (i,j) to result
        }
      }
    }
    // compute the mean of pixel at (x,y) and its neighbors
    return (result.reduce((x,y) => x+y, 0)) / result.length;
  }
  return [0,1,2].map(blurChannel); // map through rgb channels
}

/* function blurImage has the following type: blurImage(img: Image): Image
The result is a new image that is the blurred version of the argument, with pixels obtained
by applying blurPixel to each pixel of the input image. Uses higher order functions. */

function blurImage(img) {
  return imageMapXY(img, blurPixel);
}

/* function diffLeft has the following type: diffLeft(img: Image, x: number, y: number): Pixel
which returns a grayscale pixel representing the intensity difference between pixel (x, y) and pixel
(x-1, y) if the latter exists (otherwise, consider there is no intensity difference). Calculate the mean
value of the three color channels for pixel (x, y) (call it m1) and the mean value of pixel (x-1, y)
(call it m2). Set all three channels of the result to |m2-m1|.*/

function diffLeft(img, x, y) {
  if(x-1 >= 0) {
    let m1 = img.getPixel(x,y).reduce((x,y) => x+y, 0) / 3;
    let m2 = img.getPixel(x-1, y).reduce((x,y) => x+y, 0) / 3;
    let result = Math.abs(m1-m2);
    return [result,result,result];
  }
  return [0,0,0];
}

/* function highlightEdges takes an image as argument and returns a new
grayscale version of the input image with highlighted edges. To do so, applies diffLeft to each
pixel.*/

function highlightEdges(img) {
  return imageMapXY(img, diffLeft);
}

/* function reduceFunctions has the following type: reduceFunctions(fa: ((p: Pixel) => Pixel)[] ): ((x: Pixel) => Pixel)
That is, reduceFunctions takes an array of functions, each taking a pixel and returning a pixel.
It returns a single function (also from pixel to pixel) that composes all functions in the array, with
the function at index 0 applied to the pixel first.*/
function reduceFunctions(fa) {
  return x => fa.reduce((acc, f) => f(acc), x);
}

/* function combineThree has the following type: combineThree(img: Image): Image
The result is a new image where each pixel is transformed successively as done by the functions
makeGrayish, blackenLow and shiftRGB, in this order. Uses imageMap and reduceFunctions.*/

function isGrayish2(p){
  let min = p.reduce((x,y) => Math.min(x,y), p[0]);
  let max = p.reduce((x,y) => Math.max(x,y), p[0]);
  return ((max-min) <= (1/3))? true: false;
}
// modified version of makeGrayish
function makeGrayish2(p){
  if (isGrayish2(p)) { return p;}
  let avg = (p[0] + p[1] + p[2]) / 3;
  return [avg, avg, avg];
}

// modified version of blackenLow
function blackenLow2(p){
  return p.map(x => (x < 1/3)? 0: x);
}

// modified version of shiftRGB
function shiftRGB2(p) {
  return [p[1], p[2], p[0]]; // returns the new image with (g,b,r) settings
}

function imageMap(img, func) {
  let newIm = img.copy();
  for (let i = 0; i < newIm.width; ++i){ // iterating through the image pixels by row
    for (let j = 0; j < newIm.height; ++j){ // iterating through each pixel in row i
        newIm.setPixel(i,j,func(newIm.getPixel(i,j))); // set new pixel as result of applying func to the pixel at i, j
    }
  }
  return newIm; // returns the new image with new settings applied by func
}

function combineThree(img){
  let arr = [makeGrayish2, blackenLow2, shiftRGB2];
  return imageMap(img, reduceFunctions(arr));
}


// test cases:

// output images
let robot = lib220.loadImageFromURL('https://people.cs.umass.edu/~joydeepb/robot.jpg');
robot.show(); // original
removeBlueAndGreen(robot).show(); // red
shiftRGB(robot).show(); // gbr
mapToRed(robot).show(); // red
mapToGBR(robot).show(); // gbr
increaseContrast(robot).show(); // increased contrast

// tests from prompt
test('removeBlueAndGreen function definition is correct', function() {
  const white = lib220.createImage(10, 10, [1,1,1]);
  removeBlueAndGreen(white).getPixel(0,0);
  // Checks that code runs. Need to use assert to check properties.
});

test('No blue or green in removeBlueAndGreen result', function() {
  // Create a test image, of size 10 pixels x 10 pixels, and set it to all white.
  const white = lib220.createImage(10, 10, [1,1,1]);
  // Get the result of the function.
  const shouldBeRed = removeBlueAndGreen(white);
  // Read the center pixel.
  const pixelValue = shouldBeRed.getPixel(5, 5);
  // The red channel should be unchanged.
  assert(pixelValue[0] === 1);
  // The green channel should be 0.
  assert(pixelValue[1] === 0);
  // The blue channel should be 0.
  assert(pixelValue[2] === 0);
});

function pixelEq (p1, p2) {
  const epsilon = 0.002; 
  for (let i = 0; i < 3; ++i) {
    if (Math.abs(p1[i] - p2[i]) > epsilon) {
      return false;
    }
  }
  return true;
};

test('Check pixel equality', function() {
  const inputPixel = [0.5, 0.5, 0.5]
  // Create a test image, of size 10 pixels x 10 pixels, and set it to the inputPixel
  const image = lib220.createImage(10, 10, inputPixel);
  // Process the image.
  const outputImage = removeBlueAndGreen(image);
  // Check the center pixel.
  const centerPixel = outputImage.getPixel(5, 5);
  assert(pixelEq(centerPixel, [0.5, 0, 0]));
  // Check the top-left corner pixel.
  const cornerPixel = outputImage.getPixel(0, 0);
  assert(pixelEq(cornerPixel, [0.5, 0, 0]));
});

// General tests
// imageMapXY
let url = 'https://people.cs.umass.edu/~joydeepb/robot.jpg';
robot = lib220.loadImageFromURL(url);
imageMapXY(robot, function(img, x, y) { return [img.getPixel(x, y)[0], 0, 0];}).show();

// imageMask
imageMask(robot, function(img,x,y){ return (y % 10 === 0); }, [1, 0, 0]).show();

// imageMapCond
imageMapCond(robot, function(img,x,y){ return (y % 10 === 0); }, p => [0, p[1], 0]).show(); // blue stripes

// makeGrayish
makeGrayish(robot).show();

// grayHalfImage
grayHalfImage(robot).show();

// blackenLow
blackenLow(robot).show();

// TESTING

// isGrayish
test('isGrayish works as it should because I am perfect and I can code like a girlboss boom pow', function() {
  // Create a test pixel that is grayish
  assert(isGrayish([0.5, 0.4, 0.4])); // grayish
  assert(!isGrayish([1, 0.1, 0.1])); // not grayish
  assert(!isGrayish([0.34, 0, 0])); // not grayish
});


// basic test with robot

url = 'https://people.cs.umass.edu/~joydeepb/robot.jpg';
robot = lib220.loadImageFromURL(url);
robot.show();

// blur image
blurImage(robot).show();

// test for diffLeft/highlightEdges
highlightEdges(robot).show();

// test combineThree
combineThree(robot).show();


// Tests
function pixelEq (p1, p2) {
  const epsilon = 0.002; 
  for (let i = 0; i < 3; ++i) {
    if (Math.abs(p1[i] - p2[i]) > epsilon) {
      return false;
    }
  }
  return true;
};

test('blurPixel returns same pixel with uniform image', function() {
  const image2 = lib220.createImage(3, 3, [1,1,1]);
  assert(pixelEq(blurPixel(image2,1,1), [1, 1, 1]));

  const image3 = lib220.createImage(3, 3, [0.5,0.5,0.5]);
  assert(pixelEq(blurPixel(image3,1,1), [0.5, 0.5, 0.5]));
});

test('blurPixel returns correct pixel on edge cases', function(){
  const image = lib220.createImage(3, 3, [0,0,0]);

  image.setPixel(0,0,[0.1,0.1,0.1]);
  image.setPixel(0,1,[0.2,0.2,0.2]);
  image.setPixel(0,2,[0.3,0.3,0.3]);
  image.setPixel(1,0,[0.4,0.4,0.4]);
  image.setPixel(1,1,[0.5,0.5,0.5]);
  image.setPixel(1,2,[0.6,0.6,0.6]);
  image.setPixel(2,0,[0.7,0.7,0.7]);
  image.setPixel(2,1,[0.8,0.8,0.8]);
  image.setPixel(2,2,[0.9,0.9,0.9]);

  assert(pixelEq(blurPixel(image,1,1), [0.5, 0.5, 0.5]));
  // edge case 1
  let avg = (0.1+0.2+0.4+0.5)/4
  assert(pixelEq(blurPixel(image,0,0), [avg, avg, avg]));
  // edge case 2
  avg = (0.9+0.8+0.6+0.5)/4
  assert(pixelEq(blurPixel(image,2,2), [avg, avg, avg]));
  // another case
  avg = (0.4+0.5+0.6+0.7+0.8+0.9)/6
  assert(pixelEq(blurPixel(image,2,1), [avg, avg, avg]));
});

test('blurImage returns same image on image with uniform pixels', function() {
  const image = lib220.createImage(3, 3, [0,0,0]);
  for (let x = 0; x <= 2; ++x){
    for (let y = 0; y <= 2; ++y){
      assert(pixelEq(blurImage(image).getPixel(x,y), [0,0,0]));
      }
    }
});

test('diffLeft returns same pixel with uniform image', function() {
  // no pixel difference
  const image = lib220.createImage(3, 3, [0.2,0.1,0.8]);
  // test when x = 1
  assert(pixelEq(diffLeft(image,1,1), [0, 0, 0]));
  // test when x = 0
  assert(pixelEq(diffLeft(image,0,1), [0, 0, 0]));
});

test('diffLeft returns correct pixel', function() {
  const image = lib220.createImage(3, 3, [0.2,0.1,0.8]);
  // set pixel difference
  image.setPixel(0,1,[0.5,0.2,0.9]);
  let result = Math.abs( (0.5+0.2+0.9)/3 - (0.2+0.1+0.8)/3);
  assert(pixelEq(diffLeft(image,1,1), [result, result, result]));
});

test('highlightEdges returns no difference with a uniform pixel image', function() {
   const image = lib220.createImage(3, 3, [0.2,0.1,0.8]);
   for (let x = 0; x <= 2; ++x){
    for (let y = 0; y <= 2; ++y){
      assert(pixelEq(highlightEdges(image).getPixel(x,y), [0,0,0]));
      }
    }
});

test('reduceFunctions returns correct pixel with one function applied', function() {
  let g = p => [p[0], p[1], 0];
  assert(pixelEq(reduceFunctions([g])([1,2,3]),[1,2,0]));
});

test('reduceFunctions returns same pixel with no functions as input', function() {
  assert(pixelEq(reduceFunctions([])([1,2,3]),[1,2,3]));
});

test('combineThree returns an image with three transformations', function() {
   let url2 = 'https://people.cs.umass.edu/~joydeepb/robot.jpg';
   let robot2 = lib220.loadImageFromURL(url2);
   let newIm = imageMap(imageMap(imageMap(robot2, makeGrayish2), blackenLow2), shiftRGB2);
   assert(pixelEq(newIm.getPixel(1,1), combineThree(robot2).getPixel(1,1)));
});

test('combineThree returns a different image from original', function() {
   let url = 'https://people.cs.umass.edu/~joydeepb/robot.jpg';
   let robot = lib220.loadImageFromURL(url);
   assert(!pixelEq(robot.getPixel(1,1), combineThree(robot).getPixel(1,1)));
});
