/*
Haejin Lee
Image Processing
*/

/* 1. function removeBlueAndGreen takes an image as an argument and returns a copy of
the input image, where each pixel is a shade of red. If
the color of a pixel is (r, g, b) in the input image, its
color in the outputi is (r, 0, 0). */

function removeBlueAndGreen(img) {
  let red = img.copy(); // red is copy of im which will be returned
  for (let i = 0; i < red.width; ++i){ // iterating through red's pixels by row
    for (let j = 0; j < red.height; ++j){ // iterating through each pixel in row i
        red.setPixel(i, j, [red.getPixel(i,j)[0], 0, 0]); // only takes first (red) parameter of pixel
    }
  }
  return red; // returns the red image
}

/* 2. function shiftRGB takes an image as an argument and returns a copy of the input
image, where all the channels are shifted. If the color of a pixel is (r, g, b) in the input image, its color
in the output is (g, b, r).*/

function shiftRGB(img) {
  let newIm = img.copy(); // newIm is the image that will be returned
  for (let i = 0; i < newIm.width; ++i){ // iterating through the image pixels by row
    for (let j = 0; j < newIm.height; ++j){ // iterating through each pixel in row i
        newIm.setPixel(i, j, [newIm.getPixel(i,j)[1], newIm.getPixel(i,j)[2], newIm.getPixel(i,j)[0]]); // changes (r,g,b) to (g,b,r)
    }
  }
  return newIm; // returns the new image with (g,b,r) settings
}

/* function imageMap has the following type:
imageMap(img: Image, func: (p: Pixel) => Pixel): Image
The result is a new image with the same dimensions as img. The value of each pixel in the new
image should be the result of applying func to the corresponding pixel of img. Uses image.copy to make a copy of the original.
*/

function imageMap(img, func) {
  let newIm = img.copy();
  for (let i = 0; i < newIm.width; ++i){ // iterating through the image pixels by row
    for (let j = 0; j < newIm.height; ++j){ // iterating through each pixel in row i
        newIm.setPixel(i,j,func(newIm.getPixel(i,j))); // set new pixel as result of applying func to the pixel at i, j
    }
  }
  return newIm; // returns the new image with new settings applied by func
}

/* functions mapToRed and mapToGBR behave exactly like removeBlueAndGreen and shiftRGB but use imageMap.*/

function mapToRed(img) {
  return imageMap(img, p => [p[0], 0, 0] ); // calls image map to change image pixels from (r,g,b) to (r, 0, 0)
}

function mapToGBR(img) {
  return imageMap(img, p => [p[1], p[2], p[0]] ); // calls image map to change image pixels from (r,g,b) to (g,b,r)
}

/* function increaseContrast returns a copy of the input image where each color
channel of a pixel is shifted towards the closest of the two limits 0 or 1. Specifically, the difference to
the closest of the two limits (0 or 1) is decreased by 10% of its value. For example, 0.6 becomes 0.64
and 0.3 becomes 0.27. A channel value of 0.5 is not changed (but, as you will see, images cannot have
channel values of precisely 0.5).
Uses imageMap and map - no loops. */

function increaseContrast(img) {
  return imageMap(img, img => img.map(contrast)); // function will apply to each pixel of image and change its contrast
}

function contrast(p){
  if (p > 0.5) { p += (0.1 * (1-p));} // if pixel value is closer to 1, add 10% difference
  if (p < 0.5) { p -= (0.1*p);} // if pixel value is closer to 0, subtract 10% difference
  if (p >= 1) { return 1;} // check upper bound
  if (p <= 0) { return 0;} // check lower bound
  return p;
}


/*
Homework 2: More Image Processing with Higher-Order Functions
*/

/* function imageMapXY has the following type:
    imageMapXY(img: Image, func: (img: Image, x: number, y: number) => Pixel): Image
  The result is a new image with the same dimensions as img. 
  The value of each pixel in the new image is the result of
  applying func to the corresponding pixel of img. 
  This function is more general than imageMap: the new pixel value 
  may also depend on the coordinates of the original pixel.
*/
function imageMapXY(img, func) {
  let newIm = img.copy(); // copy the image
  for (let x = 0; x < newIm.width; ++x){ // iterating through the image pixels by rows x
    for (let y = 0; y < newIm.height; ++y){ // iterating through each column y in row x
        newIm.setPixel(x,y,func(img, x, y)); // set new pixel as result of applying func to the pixel at x,y coordinates
    }
  }
  return newIm; // returns the new image with new settings applied by func
}

/* function imageMask has the following type:
  imageMask(img: Image, cond: (img: Image, x: number, y: number) => boolean, maskValue: Pixel): Image
  The result is a new image, in which the value of pixel at
  (x, y) is either (a) identical to the value of the pixel at (x, y) in the
  original image when cond(img, x, y) returns false or
  (b) the value maskValue when cond(img, x, y) returns true. Uses imageMapXY defined above.
*/
function imageMask(img, cond, maskValue){
  return imageMapXY(img, function(img, x, y){ // calls imageMapXY
     return cond(img, x, y)? maskValue : (img.getPixel(x,y))}); // if condition is true, return the mask value, if not return original value
}

/* function imageMapCond has the following type:
  imageMapCond(img: Image, cond: (img: Image, x: number, y: number) => boolean, 
  func: (p: Pixel) => Pixel): Image
  The result is a new image, where the value of pixel at (x, y) is either (a) identical to the value of the
  pixel at (x, y) in the original image when cond(img, x, y) returns false or (b) the value func(p),
  where p is the original pixel, when cond(img, x, y) returns true. No loops in this function, only imageMapXY
*/
function imageMapCond(img, cond, func){
  return imageMapXY(img, function(img, x, y){ // calls imageMapXY
     return cond(img, x, y)? func(img.getPixel(x,y)) : (img.getPixel(x,y));
    }); // return image of if condition is true, return pixel with function, or return original image pixel
}

/*
  4. function isGrayish has the following type: isGrayish(p: Pixel): boolean
  The result is true if and only if the difference between the maximum and minimum color channel
  value is at most 1/3.
*/
function isGrayish(p){
  let min = p.reduce((x,y) => Math.min(x,y), p[0]);
  let max = p.reduce((x,y) => Math.max(x,y), p[0]);
  return ((max-min) <= (1/3))? true: false;
}

/*
  5. function makeGrayish has the following type: makeGrayish(img: Image): Image
  The result is a new image, where each grayish pixel, as determined by the isGrayish() function, is
  left unchanged. Any other pixel is replaced with a grayscale pixel computed by averaging the three color
  channels, and setting all three channels in the new pixel to this value.
*/
function makeGrayish(img){
  return imageMapCond(img, // calls imageMapCond
  (img, x, y) => (isGrayish(img.getPixel(x,y)) === false), // condition is pixels that AREN'T grayish
  function(p){
    let avg = (p[0] + p[1] + p[2]) / 3;
    return [avg, avg, avg];}
  ); 
} // average above lol couldn't comment for some reason

/*
  6. function grayHalfImage has the following type: grayHalfImage(img: Image): Image
  The result is a new image that is the half-grayed version of the argument, where the top part of the
  image is grayed out and the bottom part of the image is in color. If the y-position is less than half of the
  image height, then this part is transformed like the makeGrayish function above.
*/
function grayHalfImage(img){
  return imageMapCond(img, 
   (img, x, y) => ( y < (1/2*(img.height)) && isGrayish(img.getPixel(x,y)) === false ) ,
  function(p){
    let avg = (p[0] + p[1] + p[2]) / 3;
    return [avg, avg, avg];}
  );
}
/*
  7. function blackenLow has the following type: blackenLow(img: Image): Image
  The result is a new image where, for each pixel, any channel value lower than 1/3 is set to 0 for the
  corresponding pixel in the new image. Other channels for the pixel are not modified.
*/
function blackenLow(img){
  return imageMapXY(img, 
  (img, x, y) => img.getPixel(x,y).map(x => (x < 1/3)? 0: x));
}
// test cases:


// output images
let robot = lib220.loadImageFromURL('https://people.cs.umass.edu/~joydeepb/robot.jpg');
robot.show(); // original
removeBlueAndGreen(robot).show(); // red
shiftRGB(robot).show(); // gbr
mapToRed(robot).show(); // red
mapToGBR(robot).show(); // gbr
increaseContrast(robot).show(); // increased contrast

// tests from prompt
test('removeBlueAndGreen function definition is correct', function() {
  const white = lib220.createImage(10, 10, [1,1,1]);
  removeBlueAndGreen(white).getPixel(0,0);
  // Checks that code runs. Need to use assert to check properties.
});

test('No blue or green in removeBlueAndGreen result', function() {
  // Create a test image, of size 10 pixels x 10 pixels, and set it to all white.
  const white = lib220.createImage(10, 10, [1,1,1]);
  // Get the result of the function.
  const shouldBeRed = removeBlueAndGreen(white);
  // Read the center pixel.
  const pixelValue = shouldBeRed.getPixel(5, 5);
  // The red channel should be unchanged.
  assert(pixelValue[0] === 1);
  // The green channel should be 0.
  assert(pixelValue[1] === 0);
  // The blue channel should be 0.
  assert(pixelValue[2] === 0);
});

function pixelEq (p1, p2) {
  const epsilon = 0.002; 
  for (let i = 0; i < 3; ++i) {
    if (Math.abs(p1[i] - p2[i]) > epsilon) {
      return false;
    }
  }
  return true;
};

test('Check pixel equality', function() {
  const inputPixel = [0.5, 0.5, 0.5]
  // Create a test image, of size 10 pixels x 10 pixels, and set it to the inputPixel
  const image = lib220.createImage(10, 10, inputPixel);
  // Process the image.
  const outputImage = removeBlueAndGreen(image);
  // Check the center pixel.
  const centerPixel = outputImage.getPixel(5, 5);
  assert(pixelEq(centerPixel, [0.5, 0, 0]));
  // Check the top-left corner pixel.
  const cornerPixel = outputImage.getPixel(0, 0);
  assert(pixelEq(cornerPixel, [0.5, 0, 0]));
});

// General tests
// imageMapXY
let url = 'https://people.cs.umass.edu/~joydeepb/robot.jpg';
robot = lib220.loadImageFromURL(url);
imageMapXY(robot, function(img, x, y) { return [img.getPixel(x, y)[0], 0, 0];}).show();

// imageMask
imageMask(robot, function(img,x,y){ return (y % 10 === 0); }, [1, 0, 0]).show();

// imageMapCond
imageMapCond(robot, function(img,x,y){ return (y % 10 === 0); }, p => [0, p[1], 0]).show(); // blue stripes

// makeGrayish
makeGrayish(robot).show();

// grayHalfImage
grayHalfImage(robot).show();

// blackenLow
blackenLow(robot).show();

// TESTING

// isGrayish
test('isGrayish works as it should because I am perfect and I can code like a girlboss boom pow', function() {
  // Create a test pixel that is grayish
  assert(isGrayish([0.5, 0.4, 0.4])); // grayish
  assert(!isGrayish([1, 0.1, 0.1])); // not grayish
  assert(!isGrayish([0.34, 0, 0])); // not grayish
});

